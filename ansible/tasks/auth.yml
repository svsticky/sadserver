---
# Contains a snapshot of the hostkeys of github.com, so these can be validated
# at runtime
- name: "install system-wide known hostkeys"
  template:
    src: "templates/etc/ssh/ssh_known_hosts"
    dest: "/etc/ssh/ssh_known_hosts"
    owner: "root"
    group: "root"
    mode: "0644"

- name: "set NOPASSWD for sudo group in staging"
  lineinfile:
    dest: "/etc/sudoers.d/ansible"
    line: "%sudo ALL=(ALL:ALL) NOPASSWD:ALL"
    state: "{% if staging == 'true' %}present{% else %}absent{% endif %}"
    create: true
    validate: "visudo -cf %s"

# Hack, to make it possible to set your password as admin when you login. Resets
# the password at every login.
- name:
    "require the admin user to immediately choose a new password in production"
  command: "passwd -de {{ item.name }}"
  when:
    # List is evaluated as logical AND
    - staging == 'false'
    - item.admin
    - item.state == "present"
    - item.name != "ansible"
  with_items:
    - "{{ users }}"
  loop_control:
    label: "{{ item.name }}"

- name: "ensure .ssh-directory is present at all users"
  file:
    path: "{{ item.0.home_prefix }}/{{ item.0.name }}/.ssh"
    state: "directory"
    owner: "{{ item.0.name }}"
    group: "{{ item.0.name }}"
    mode: "0755"
  when: item.0.state == 'present'
  with_subelements:
    - "{{ users }}"
    # "Keys" is added to the loop, so the directory is not created if there are
    # no keys
    - "keys"
  loop_control:
    label: "{{ item.0.name }}"

- name: "ensure SSH keys for users are present"
  blockinfile:
    path: "{{ item.0.home_prefix }}/{{ item.0.name }}/.ssh/authorized_keys"
    block: "{{ lookup('file', 'credentials/ssh/' + item.1.id) }}"
    state: "{{ item.1.state }}"
    # When changing value of marker, also update it in task down below
    marker: "# {mark} SSH key for {{ item.1.id }}"
    owner: "{{ item.0.name }}"
    group: "{{ item.0.name }}"
    create: true
  # Only run the above logic when we still want the user to exist.
  when: item.0.state == 'present'
  with_subelements:
    - "{{ users }}"
    - "keys"
  loop_control:
    label:
      user: "{{ item.0.name }}"
      key: "{{ item.1.id }}"

- name: "copy deploy key (private) for private projects on GitHub"
  copy:
    content: "{{ secret_deploy_key }}"
    dest: "/home/ansible/.ssh/deploy_ed25519"
    owner: "ansible"
    group: "ansible"
    mode: "0600"

- name: "copy deploy key (public) for private projects on GitHub"
  template:
    src: "templates/{{ item }}.j2"
    dest: "/{{ item }}"
    owner: "ansible"
    group: "ansible"
    mode: "0600"
  with_items:
    - "home/ansible/.ssh/deploy_ed25519.pub"

- name: "symlink deploy keys for root"
  file:
    src: "/home/ansible/.ssh/{{ item.src }}"
    path: "/root/.ssh/{{ item.dest }}"
    state: link
  with_items:
    - src: "deploy_ed25519"
      dest: "id_ed25519"
    - src: "deploy_ed25519.pub"
      dest: "id_ed25519.pub"

- name: "remove public keys for root account"
  file:
    path: "/root/.ssh/authorized_keys"
    state: "absent"

# The bootstrap script adds the SSH keys (as added by DO), to the ansible user.
# Afterwards, they are re-added and managed by Ansible itself, so the old
# duplicates must be deleted once.
- block:
  - name:
      "save current list of public keys for ansible user"
    vars:
      auth_keys: "~/.ssh/authorized_keys"
    shell:
      "tail -n +$(grep -nm 1 '# BEGIN SSH key' {{ auth_keys }} | cut -f1 -d:)
      {{ auth_keys }}"
    register: "ansible_user_public_keys"
    changed_when: false
    check_mode: false

  - name:
      "remove superfluous public keys for ansible user, added by bootstrap
      script"
    copy:
      content: "{{ ansible_user_public_keys.stdout + '\n' }}"
      dest: "~/.ssh/authorized_keys"
  become: false

- name: "copy hardened sshd configuration"
  template:
    src: "templates/{{ path }}.j2"
    dest: "/{{ path }}"
  vars:
    path: "etc/ssh/sshd_config"
  notify: "reboot server"
